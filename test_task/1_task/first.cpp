#include "first.h"
#include <iostream>

// нет смысла принимать int не по значению, т.к. 
// если принимать по константной ссылке будет то же самое по скорости
// (даже медленнее, потому что в большенстве процессоров есть регистры для int,
// которые работают быстрее чем разименование указателя).
//
// возвращать const char* тоже не вижу необходимости, 
// потому что мы сделали всё что хотели с этим массивом, 
// дальше уже не наша забота изменят его или нет.
char* t1::as_binary(int num)
{
	// узнаем размер целого числа занимаемый в памяти в битах
	constexpr int bits = sizeof(num) * 8;
	// выделяем массив для зависи в него двоичного вида 
	// на 1 элемент больше для завершающего нуля
	char* out = new char[bits + 1];
	out[bits] = '\0';
	// проходим по каждому биту, bits раз
	for (int ipos = 0, step = bits - 1; ipos < bits; ++ipos, --step) {
		// смещаем проверяемый бит влево затем проверяем чему он равен (применяем маску 1)
		// если он 0, то в массив запишется '0' если 1, то '1'
		out[ipos] = ((num >> step) & 1) + '0';
	}
	// возвращаем указатель на заполненный массив, 
	// за удалением массива пользователь следит сам
	return out; 
}

void t1::print_as_binary(int num)
{
	auto* bin = as_binary(num);
	// так как мы пишем на с++, то использую плюсовый вывод
	std::cout << bin << std::endl;
	delete[] bin;
}
